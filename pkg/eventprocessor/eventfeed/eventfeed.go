package eventfeed

import (
	"context"
	"fmt"
	"math/big"
	"reflect"
	"time"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/core/types"
	tbleth "github.com/textileio/go-tableland/pkg/tableregistry/impl/ethereum"
)

type EthClient interface {
	SubscribeNewHead(ctx context.Context, ch chan<- *types.Header) (ethereum.Subscription, error)
	FilterLogs(ctx context.Context, query ethereum.FilterQuery) ([]types.Log, error)
	HeaderByNumber(ctx context.Context, block *big.Int) (*types.Header, error)
}

type EventFeed interface {
	Start(ctx context.Context, fromHeight int64, ch chan<- BlockEvents, filterEventTypes []EventType) error
}

type BlockEvents struct {
	BlockNumber int64
	Events      []interface{}
}

type EventType string

const (
	RunSQL   EventType = "RunSQL"
	Transfer           = "Transfer"
)

var (
	// SupportedEvents contains a map from **all** EventType values
	// to the corresponding struct that will be used for unmarshaling.
	// Note that tbleth.Contract*** is automatically generated by
	// `make ethereum`, so keeping this mapping is easy since these
	// structs are generated from the contract ABI.
	//
	// IMPORTANT: we should *always* have a mapping for all EventType
	// values.
	SupportedEvents = map[EventType]reflect.Type{
		RunSQL:   reflect.TypeOf(tbleth.ContractRunSQL{}),
		Transfer: reflect.TypeOf(tbleth.ContractTransfer{}),
	}
)

type Config struct {
	MinBlockChainDepth int
	MaxEventsBatchSize int
	ChainAPIBackoff    time.Duration
}

func DefaultConfig() *Config {
	return &Config{
		MinBlockChainDepth: 5,
		MaxEventsBatchSize: 10000,
		ChainAPIBackoff:    time.Second * 15,
	}
}

type Option func(*Config) error

func WithMinBlockChainDepth(depth int) Option {
	return func(c *Config) error {
		if depth < 0 {
			return fmt.Errorf("depth must non-negative")
		}
		c.MinBlockChainDepth = depth
		return nil
	}
}

func WithMaxEventsBatchSize(batchSize int) Option {
	return func(c *Config) error {
		if batchSize <= 0 {
			return fmt.Errorf("batch size should greater than zero")
		}
		c.MaxEventsBatchSize = batchSize
		return nil
	}
}

func WithChainAPIBackoff(backoff time.Duration) Option {
	return func(c *Config) error {
		if backoff < time.Second {
			return fmt.Errorf("chain api backoff is too low (<1s)")
		}
		c.ChainAPIBackoff = backoff
		return nil
	}
}
